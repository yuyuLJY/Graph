#include <stdio.h>
#include <stdlib.h>
#include <time.h>
#define MaxVertexNum 20 //顶点数设置为100
#define INFINITY 100000
#define maxSize 100
#define ERROR -1
#define MAXK 1e3
clock_t start,stop;
double duration;
typedef enum{false = 0,true = 1}PointTag;
int visited[MaxVertexNum];
typedef int weightType;
typedef char dataType;
//邻接矩阵的结构体
/*邻接矩阵*/
struct GNode{
    int nv;//顶点数
    int ne;//边数
    weightType G[MaxVertexNum][MaxVertexNum];//邻接矩阵某条边的权值
    dataType data[MaxVertexNum];//存顶点的数据
};
typedef struct GNode *MGraph;

/*邻接矩阵边的定义*/
typedef int Vertex;
struct ENode{
    Vertex v1,v2;
    weightType weight;
};
typedef struct ENode *Edge;

//邻接表的结构体
/*邻接点的定义*/
struct AdjvNode{
    Vertex Adjv;//邻接点的下标
    weightType weight;
    struct AdjvNode *next;
};
typedef struct AdjvNode *PtrToAdjvNode;


/*顶点表头结点的定义*/
struct Vnode{
    PtrToAdjvNode firstEdge;//边表头指针
    dataType data;
};
//开辟顶点结点的数组
typedef struct Vnode AdjList[MaxVertexNum];


/*邻接表-图的定义*/
struct GNode_AL{
    int nv;
    int ne;
    AdjList G;//邻接表
};
typedef struct GNode_AL *LGraph;

typedef Vertex element1;//队列的元素是“边”
typedef int position;
struct QNode{
    element1 data1[maxSize];//存储元素的数组,数组里边放的全部都是指针
    position front,rear;//队列的头尾指针
};
typedef struct QNode *queue;//没有*不行？？？

/*十字链表的结构体*/
//结点结构
struct ArcNode{
    int tailvex,headvex;//弧的头和顶点的位置
    struct ArcNode *hlink,*tlink;//头尾指针
    weightType weight;//邻接点下标？？
};
typedef struct ArcNode *Arcbox;

//头结点
struct XNode{
    dataType data;
    Arcbox firstIn,firstOut;
};
typedef struct XNode xlist[MaxVertexNum];

/*十字链表-图的定义*/
struct OLGNode{
    int nv;
    int ne;
    xlist G;//邻接表
};
typedef struct OLGNode *OLGraph;

Vertex accessVisit();//想要去开始进入的点
void InitialVisted();//初始化访问tag
MGraph biuldGraph_matric();
MGraph CreateGraph_matric(int nvNum);//初始化有nv个顶点但没有边的图
void InsertEdge_matric(MGraph Graph,Edge E);//在矩阵中插入边

queue CreatQueue();//创建空队列
int Isfull(queue Q);//列队是不是满的
void addQ(queue Q,element1 x);//添加新队列
int isEmpty(queue Q);//判断队列是否为空
element1 deleteQ(queue Q);//删除队列中的元素,返回弹出的地址
void visit_(Vertex s);
int IsEdge(MGraph Graph,Vertex v,Vertex w);//判断是不是边
void InitialVisted();//初始化访问tag
LGraph biuldGraph_adjacencyList();//建立邻接表的图
LGraph CreateGraph_adjacencyList(int nvNum);//初始化有nv个顶点但没有边的图
void InsertEdge_adjacencyList(LGraph Graph,Edge E);//把这条边插入邻接表信息中
OLGraph biuldGraph_arc();//建立十字链表的图
OLGraph CreateGraph_arc(int nvNum);
void InsertEdge_arc(OLGraph Graph,Edge E);//把这条边插入十字链表信息中

void BFS_matric(MGraph Graph,Vertex s,void(*visit_)(Vertex));//邻接矩阵的广度优先搜索
void DFS_matric(MGraph Graph,Vertex v,void(*visit_)(Vertex));//邻接矩阵的深度递归搜索
void In_DFS_matric(MGraph Graph,Vertex v,void(*visit_)(Vertex));//邻接矩阵的深度递归搜索

void DFS_adjacencyList(LGraph Graph,Vertex v,void(*visit_)(Vertex));//邻接表的深度搜索
void In_DFS_adjacencyList(LGraph Graph,Vertex v,void(*visit_)(Vertex));//邻接表的深度搜索
void BFS_adjacencyList(LGraph Graph,Vertex v,void(*visit_)(Vertex));//邻接表的广度搜索

void BFS_arc(OLGraph Graph,Vertex s,void(*visit_)(Vertex));//十字链表的广度优先搜索
void DFS_arc(OLGraph Graph,Vertex v,void(*visit_)(Vertex));//十字链表的深度递归搜索
void In_DFS_arc(OLGraph Graph,Vertex v,void(*visit_)(Vertex));//十字链表的深度递归搜索

int FirstAdjVex(OLGraph Graph,int v);
int NextAdjVex(OLGraph Graph,int v,int w);

void way1();//方式一
LGraph fromMatricToadjacencyList(MGraph Graph1);//从邻接矩阵到邻接链表
OLGraph fromMatricToArcList(MGraph Graph1);

void way2();//方式二
MGraph fromAdjacencyListTomatric(LGraph Graph1);
OLGraph fromAdjacencyListToArcList(LGraph Graph1);//邻接表变成十字链表

void way3();
MGraph fromArcTomatric(OLGraph Graph1);//十字链表变成邻接矩阵
LGraph fromArcToAdjacencyList(OLGraph Graph1);//十字链表变成邻接链表

LGraph Prim_matric(MGraph Graph);//最小生成树
Vertex findMinDist_matric(MGraph Graph,weightType dist[]);
LGraph Prim_adjacencyList(LGraph Graph);//最小生成树
Vertex findMinDist_adjacencyList(LGraph Graph,weightType dist[]);//寻找最小的权值点
void run1(MGraph Graph);//时间的比较 邻接矩阵的广度
void run2(LGraph Graph);
void run3(OLGraph Graph);
int main()
{

    //从邻接矩阵到十字链表+邻接表
    way1();
    //从邻接表到十字链表+邻接矩阵
    //way2();
    //从十字链表到邻接表+邻接矩阵
    //way3();
    return 0;
}

//方式一
void way1(){
    MGraph Graph1;
    LGraph Graph2,Graph4,Graph5;
    OLGraph Graph3;
    Vertex s=accessVisit();//开始访问的结点
    InitialVisted();//初始化访问tag
    Graph1=biuldGraph_matric();
    //从邻接矩阵到十字链表，邻接表
    Graph2=fromMatricToadjacencyList(Graph1);
    Graph3=fromMatricToArcList(Graph1);
    printf("邻接矩阵的广度优先搜索：\n");
    BFS_matric(Graph1,s,visit_);
    printf("\n");

    InitialVisted();//初始化访问tag
    printf("邻接矩阵的深度递归优先搜索：\n");
    DFS_matric(Graph1,s,visit_); //邻接矩阵的深度递归搜索
    printf("\n");

    InitialVisted();//初始化访问tag
    printf("邻接矩阵的深度非递归优先搜索：\n");
    In_DFS_matric(Graph1,s,visit_); //邻接矩阵的深度非递归搜索
    printf("\n");
    //printf("%d\n",Graph->G[4][3]);
    //printf("%d\n",Graph->nv);测试，已经成功读入
    //printf("%c\n",Graph->data[2]);

    //LGraph Graph;
    //Vertex s=accessVisit();//开始访问的结点

    printf("邻接矩阵的深度最小生成树\n");
    Graph4=Prim_matric(Graph1);
    InitialVisted();//初始化访问tag
    In_DFS_adjacencyList(Graph4,s,visit_);
    printf("\n");

    InitialVisted();//初始化访问tag
    //使用矩阵来创建
    //Graph=biuldGraph_adjacencyList();
    printf("邻接表的深度优先搜索：\n");
    DFS_adjacencyList(Graph2,s,visit_); //邻接表的深度搜索
    printf("\n");

    InitialVisted();//初始化访问tag
    printf("邻接表的深度优先非递归搜索：\n");
    In_DFS_adjacencyList(Graph2,s,visit_); //邻接表的深度搜索
    printf("\n");

    printf("邻接表的广度优先搜索：\n");
    InitialVisted();//初始化访问tag
    BFS_adjacencyList(Graph2,s,visit_); //邻接表的深度搜索
    printf("\n");

    printf("邻接表的深度最小生成树\n");
    Graph5=Prim_adjacencyList(Graph2);
    InitialVisted();//初始化访问tag
    In_DFS_adjacencyList(Graph5,s,visit_);
    printf("\n");
    //读入验证正确
    //printf("%d\n",(Graph->G[4].firstEdge)->Adjv);
    //printf("%c\n",Graph->G[4].data);


    //OLGraph Graph;
    //Vertex s=accessVisit();//开始访问的结点
    //Graph=biuldGraph_arc();
    InitialVisted();//初始化访问tag

    printf("十字链表的深度优先递归搜索：\n");
    DFS_arc(Graph3,s,visit_); //邻接表的深度搜索
    printf("\n");

    InitialVisted();//初始化访问tag
    printf("十字链表的深度优先非递归搜索：\n");
    In_DFS_arc(Graph3,s,visit_); //邻接表的深度搜索
    printf("\n");

    printf("十字链表的广度优先搜索：\n");
    InitialVisted();//初始化访问tag
    BFS_arc(Graph3,s,visit_); //邻接表的深度搜索

    run1(Graph1);
    run2(Graph2);
    //run3(Graph3);

}

//从邻接矩阵到邻接链表
LGraph fromMatricToadjacencyList(MGraph Graph1){
    LGraph Graph2;
    Edge E;
    int i,j,nv;
    nv =Graph1->nv;
    Graph2=CreateGraph_adjacencyList(nv);//初始化有nv个顶点但没有边的图

    Graph2->ne= Graph1->ne;
    if(Graph2->ne!=0){
        E=(Edge)malloc(sizeof(struct ENode));
        //找出那些存在的边
        for(i=0;i<Graph1->nv;i++){
            for(j=0;j<Graph1->nv;j++){
                if(Graph1->G[i][j]<INFINITY){
                    E->v1=i;
                    E->v2=j;
                    E->weight=Graph1->G[i][j];
                    InsertEdge_adjacencyList(Graph2,E);//把这条边插入链表信息中
                }
            }
        }

    //读入顶点的数据
    for(i=0;i<Graph1->nv;i++){
        Graph2->G[i].data=Graph1->data[i];//读入A、B、C顶点的数据
    }
    }
    return Graph2;
}

//从邻接矩阵到十字链表
OLGraph fromMatricToArcList(MGraph Graph1){
    OLGraph Graph;
    Edge E;
    int i,j,nv;
    nv =Graph1->nv;
    Graph=CreateGraph_arc(nv);//初始化有nv个顶点但没有边的图

    Graph->ne= Graph1->ne;
    if(Graph->ne!=0){
        E=(Edge)malloc(sizeof(struct ENode));
        //找出那些存在的边
        for(i=0;i<Graph1->nv;i++){
            for(j=0;j<Graph1->nv;j++){
                if(Graph1->G[i][j]<INFINITY){
                    E->v1=i;
                    E->v2=j;
                    E->weight=Graph1->G[i][j];
                    InsertEdge_arc(Graph,E);//把这条边插入链表信息中
                }
            }
        }

    //读入顶点的数据
    for(i=0;i<Graph1->nv;i++){
        Graph->G[i].data=Graph1->data[i];//读入A、B、C顶点的数据
    }
    }
    return Graph;
}

void way2(){
    MGraph Graph1;
    LGraph Graph2;
    OLGraph Graph3;
    Vertex s=accessVisit();//开始访问的结点
    Graph2=biuldGraph_adjacencyList();//创建邻接表
    Graph1=fromAdjacencyListTomatric(Graph2);
    //printf("%d\n",Graph1->nv);
    Graph3=fromAdjacencyListToArcList(Graph2);
    printf("邻接表的深度优先搜索：\n");
    DFS_adjacencyList(Graph2,s,visit_); //邻接表的深度搜索
    printf("\n");

    InitialVisted();//初始化访问tag
    printf("邻接表的深度优先非递归搜索：\n");
    In_DFS_adjacencyList(Graph2,s,visit_); //邻接表的深度搜索
    printf("\n");

    printf("邻接表的广度优先搜索：\n");
    InitialVisted();//初始化访问tag
    BFS_adjacencyList(Graph2,s,visit_); //邻接表的深度搜索
    printf("\n");


    InitialVisted();//初始化访问tag
    printf("邻接矩阵的广度优先搜索：\n");
    BFS_matric(Graph1,s,visit_);
    printf("\n");

    InitialVisted();//初始化访问tag
    printf("邻接矩阵的深度递归优先搜索：\n");
    DFS_matric(Graph1,s,visit_); //邻接矩阵的深度递归搜索
    printf("\n");

    InitialVisted();//初始化访问tag
    printf("邻接矩阵的深度非递归优先搜索：\n");
    In_DFS_matric(Graph1,s,visit_); //邻接矩阵的深度非递归搜索*/
    printf("\n");

    InitialVisted();//初始化访问tag
    printf("十字链表的深度优先递归搜索：\n");
    DFS_arc(Graph3,s,visit_); //邻接表的深度搜索
    printf("\n");

    InitialVisted();//初始化访问tag
    printf("十字链表的深度优先非递归搜索：\n");
    In_DFS_arc(Graph3,s,visit_); //邻接表的深度搜索
    printf("\n");

    printf("十字链表的广度优先搜索：\n");
    InitialVisted();//初始化访问tag
    BFS_arc(Graph3,s,visit_); //邻接表的深度搜索*/
}

//邻接表变成邻接矩阵
MGraph fromAdjacencyListTomatric(LGraph Graph1){
    MGraph Graph;
    PtrToAdjvNode p;
    Edge E;
    int i,nv;
    nv =Graph1->nv;//顶点信息
    Graph=CreateGraph_matric(nv);//初始化有nv个顶点但没有边的矩阵

    Graph->ne= Graph1->ne;//定义图的边数
    if(Graph->ne!=0){
        E=(Edge)malloc(sizeof(struct ENode));
        //找出那些存在的边
        for(i=0;i<Graph1->nv;i++){
            //找到表头
            p=Graph1->G[i].firstEdge;
            while(p){
                E->v1=i;
                E->v2=p->Adjv;
                E->weight=p->weight;
                InsertEdge_matric(Graph,E);
                p=p->next;
            }
        }
    //读入顶点的数据
    for(i=0;i<Graph1->nv;i++){
        Graph->data[i]=Graph1->G[i].data;//读入A、B、C顶点的数据
    }
    }
    return Graph;
}

//邻接表变成十字链表
OLGraph fromAdjacencyListToArcList(LGraph Graph1){
    OLGraph Graph;
    PtrToAdjvNode p;
    Edge E;
    int i,nv;
    nv =Graph1->nv;
    Graph=CreateGraph_arc(nv);//初始化有nv个顶点但没有边的图

    Graph->ne= Graph1->ne;
    if(Graph->ne!=0){
        E=(Edge)malloc(sizeof(struct ENode));
        //找出那些存在的边
        for(i=0;i<Graph1->nv;i++){
            p=Graph1->G[i].firstEdge;
            while(p){
                E->v1=i;
                E->v2=p->Adjv;
                E->weight=p->weight;
                InsertEdge_arc(Graph,E);
                p=p->next;
            }
        }
    //读入顶点的数据
    for(i=0;i<Graph1->nv;i++){
        Graph->G[i].data=Graph1->G[i].data;//读入A、B、C顶点的数据
    }
    }
    return Graph;
}

void way3(){
    MGraph Graph1;
    LGraph Graph2;
    OLGraph Graph3;
    Vertex s=accessVisit();//开始访问的结点
    Graph3=biuldGraph_arc();//创建十字链表
    Graph1=fromArcTomatric(Graph3);
    Graph2=fromArcToAdjacencyList(Graph3);
    printf("邻接表的深度优先搜索：\n");
    DFS_adjacencyList(Graph2,s,visit_); //邻接表的深度搜索
    printf("\n");

    InitialVisted();//初始化访问tag
    printf("邻接表的深度优先非递归搜索：\n");
    In_DFS_adjacencyList(Graph2,s,visit_); //邻接表的深度搜索
    printf("\n");

    printf("邻接表的广度优先搜索：\n");
    InitialVisted();//初始化访问tag
    BFS_adjacencyList(Graph2,s,visit_); //邻接表的深度搜索
    printf("\n");


    InitialVisted();//初始化访问tag
    printf("邻接矩阵的广度优先搜索：\n");
    BFS_matric(Graph1,s,visit_);
    printf("\n");

    InitialVisted();//初始化访问tag
    printf("邻接矩阵的深度递归优先搜索：\n");
    DFS_matric(Graph1,s,visit_); //邻接矩阵的深度递归搜索
    printf("\n");

    InitialVisted();//初始化访问tag
    printf("邻接矩阵的深度非递归优先搜索：\n");
    In_DFS_matric(Graph1,s,visit_); //邻接矩阵的深度非递归搜索*/
    printf("\n");

    InitialVisted();//初始化访问tag
    printf("十字链表的深度优先递归搜索：\n");
    DFS_arc(Graph3,s,visit_); //邻接表的深度搜索
    printf("\n");

    InitialVisted();//初始化访问tag
    printf("十字链表的深度优先非递归搜索：\n");
    In_DFS_arc(Graph3,s,visit_); //邻接表的深度搜索
    printf("\n");

    printf("十字链表的广度优先搜索：\n");
    InitialVisted();//初始化访问tag
    BFS_arc(Graph3,s,visit_); //邻接表的深度搜索*/
}

//十字链表变成邻接矩阵
MGraph fromArcTomatric(OLGraph Graph1){
    MGraph Graph;
    Arcbox p;
    Edge E;
    int i,nv;
    nv =Graph1->nv;//顶点信息
    Graph=CreateGraph_matric(nv);//初始化有nv个顶点但没有边的矩阵

    Graph->ne= Graph1->ne;//定义图的边数
    if(Graph->ne!=0){
        E=(Edge)malloc(sizeof(struct ENode));
        //找出那些存在的边
        for(i=0;i<Graph1->nv;i++){
            //找到表头
            p=Graph1->G[i].firstOut;
            while(p){
                E->v1=i;
                E->v2=p->headvex;
                E->weight=p->weight;
                InsertEdge_matric(Graph,E);
                p=p->tlink;
            }
        }
    //读入顶点的数据
    for(i=0;i<Graph1->nv;i++){
        Graph->data[i]=Graph1->G[i].data;//读入A、B、C顶点的数据
    }
    }
    return Graph;
}

//十字链表变成邻接表
LGraph fromArcToAdjacencyList(OLGraph Graph1){
    LGraph Graph;
    Arcbox p;
    Edge E;
    int i,nv;
    nv =Graph1->nv;
    Graph=CreateGraph_adjacencyList(nv);//初始化有nv个顶点但没有边的图

    Graph->ne= Graph1->ne;
    if(Graph->ne!=0){
        E=(Edge)malloc(sizeof(struct ENode));
        //找出那些存在的边
        for(i=0;i<Graph1->nv;i++){
            p=Graph1->G[i].firstOut;
            while(p){
                E->v1=i;
                E->v2=p->headvex;
                E->weight=p->weight;
                InsertEdge_adjacencyList(Graph,E);
                p=p->tlink;
            }
        }
    //读入顶点的数据
    for(i=0;i<Graph1->nv;i++){
        Graph->G[i].data=Graph1->G[i].data;//读入A、B、C顶点的数据
    }
    }
    return Graph;
}


//想要去开始进入的点
Vertex accessVisit(){
    Vertex s =0;
    return s;
}

MGraph biuldGraph_matric(){
    MGraph Graph;
    Edge E;
    int nv,i;
    //读入顶点个数
    FILE*fp;
     if((fp=fopen("E://数据结构//图 实验//matric1.txt","r"))==NULL)
    {
        printf("fail to open!");
        exit(0);
    }
    fscanf(fp,"%d\n",&nv);//顶点个数
    Graph=CreateGraph_matric(nv);//初始化有nv个顶点但没有边的图

    fscanf(fp,"%d\n",&Graph->ne);//读入边数
    if(Graph->ne!=0){
        E=(Edge)malloc(sizeof(struct ENode));
        for(i=0;i<Graph->ne;i++){
            fscanf(fp,"%d %d %d\n",&E->v1,&E->v2,&E->weight);//读入边的信息
            InsertEdge_matric(Graph,E);//把这条边插入矩阵信息中
        }
    }
    //读入顶点的数据
    for(i=0;i<Graph->nv;i++){
        fscanf(fp,"%c",&Graph->data[i]);//读入A、B、C顶点的数据
    }
    return Graph;
}
/*
//读取文件信息,后面才做
void readText(){
}*/

//初始化有nv个顶点但没有边的图
MGraph CreateGraph_matric(int nvNum){
    Vertex v,w;
    MGraph Graph;
    //为这个图申请空间
    Graph =(MGraph)malloc(sizeof(struct GNode));
    Graph->nv=nvNum;
    //边数设置为0，并且将各条边的间距设置成无穷大，表示不连接
    Graph->ne=0;
    for(v=0;v<Graph->nv;v++){
        for(w=0;w<Graph->nv;w++){
            Graph->G[v][w]=INFINITY;
        }

    }
    return Graph;
}

//在矩阵中插入边
void InsertEdge_matric(MGraph Graph,Edge E){
    Graph->G[E->v1][E->v2]=E->weight;
}

//初始化访问tag
void InitialVisted(){
    int i;
    for(i=0;i<MaxVertexNum;i++){
        visited[i]=0;
    }
}

//邻接矩阵的广度优先搜索
void BFS_matric(MGraph Graph,Vertex s,void(*visit_)(Vertex)){
    queue Q;
    Vertex v,w;

    Q=CreatQueue();//创建空的队列

    visit_(s);//访问s顶点,并打印
    visited[s]=true;
    addQ(Q,s);//将s加入队列

    while(!isEmpty(Q)){
        v=deleteQ(Q);//把v弹出
        for(w=0;w<Graph->nv;w++){
                //判断是不是边
            if(!visited[w]&&IsEdge(Graph,v,w)){
                visit_(w);
                visited[w]=true;
                addQ(Q,w);//w入队
            }
        }
    }
}


//邻接表的广度搜索
void BFS_adjacencyList(LGraph Graph,Vertex v,void(*visit_)(Vertex)){
    PtrToAdjvNode w;
    queue Q;
    Q=CreatQueue();//创建空的队列
    if(!visited[v]){
        visit_(v);
        visited[v]=true;
        addQ(Q,v);
    }
     while(!isEmpty(Q)){
        v=deleteQ(Q);
        //两种方法都可以
        for(w=Graph->G[v].firstEdge;w;w=w->next){
            if(!visited[w->Adjv]){
                visited[w->Adjv]=true;
                visit_(w->Adjv);
                addQ(Q,w->Adjv);
            }
        }
     }
}

//十字链表的广度搜索
void BFS_arc(OLGraph Graph,Vertex v,void(*visit_)(Vertex)){
    int w;
    queue Q;
    Q=CreatQueue();//创建空的队列
    if(!visited[v]){
        visit_(v);//去访问
        visited[v]=true;//标记成已经访问
        addQ(Q,v);//放入列队中
    }
    while(!isEmpty(Q)){
        v=deleteQ(Q);
        //两种方法都可以
      /*  for(w=Graph->G[v].firstOut;w;w->tlink){
            if(!visited[w->headvex]){
                visited[w->headvex]=true;
                visit_(w->headvex);
                addQ(Q,w->headvex);
            }
        }*/
        /*在这里发现了一个前面程序的问题，前面for语句初始化的时候，没有使用{}，导致只初始化了一个指针
        ，经过检查发现for无法跳出循环，用下面的一个打印语句发现，for居然还在调用一个本来应该是NULL的空间的值*/
        for(w=FirstAdjVex(Graph,v);w>=0;w=NextAdjVex(Graph,v,w)){
            if(!visited[w]){
                visited[w]=true;
                visit_(w);
                addQ(Q,w);

            }
        }
    }

}

int FirstAdjVex(OLGraph Graph,int v){
   int w;
   if(Graph->G[v].firstOut){
        w=Graph->G[v].firstOut->headvex;
        return w;
   }
   return -1;
}

int NextAdjVex(OLGraph Graph,int v,int w){
    Arcbox p;
    p=Graph->G[v].firstOut;
    while(p->headvex!=w){
        p=p->tlink;
    }
    if(p->tlink)
    {
    //printf("执行返回\n");//3的后面不是NULL，但是应该是NULL
     //!!在这里发现问题
     return p->tlink->headvex;
    }
    else{
        //printf("执行return-1");
        return -1;
    }
}

//邻接表的深度搜索递归
void DFS_adjacencyList(LGraph Graph,Vertex v,void(*visit_)(Vertex)){
    PtrToAdjvNode w;
    visit_(v);
    visited[v]=true;

    for(w=Graph->G[v].firstEdge;w;w=w->next){
        if(!visited[w->Adjv])//下一个顶点没有被访问
            DFS_adjacencyList(Graph,w->Adjv,visit_);
    }
}

//邻接表的深度搜索非递归
void In_DFS_adjacencyList(LGraph Graph,Vertex v,void(*visit_)(Vertex)){
    PtrToAdjvNode p;
    queue Q;
    Q=CreatQueue();
    int i;
    for(i=0;i<Graph->nv;i++){
        if(!visited[i]){
        visit_(i);
        visited[i]=true;
        addQ(Q,i);
        p=Graph->G[i].firstEdge;
        while(!isEmpty(Q)){
            while(p){
                    //如果没有被访问
                if(!visited[p->Adjv]){
                    visited[p->Adjv]=true;
                    visit_(p->Adjv);
                    addQ(Q,p->Adjv);
                    //如果能找到这个结点，就走这条路，掉头
                    p=Graph->G[p->Adjv].firstEdge;
                }else{
                    p=p->next;
                }
            }
            v=deleteQ(Q);
            p=Graph->G[v].firstEdge;
        }
        }
    }
}

//十字链表的深度搜索递归
void DFS_arc(OLGraph Graph,Vertex v,void(*visit_)(Vertex)){
    Arcbox w;
    visit_(v);
    visited[v]=true;

    for(w=Graph->G[v].firstOut;w;w=w->tlink){
        if(!visited[w->headvex])//下一个顶点没有被访问
            DFS_arc(Graph,w->headvex,visit_);
    }
}

//十字链表的深度搜索非递归
void In_DFS_arc(OLGraph Graph,Vertex v,void(*visit_)(Vertex)){
    Arcbox p;
    queue Q;
    Q=CreatQueue();
    int i;
    for(i=0;i<Graph->nv;i++){
        if(!visited[i]){
        visit_(i);
        visited[i]=true;
        addQ(Q,i);
        p=Graph->G[i].firstOut;
        while(!isEmpty(Q)){
            while(p){
                    //如果没有被访问
                if(!visited[p->headvex]){
                    visited[p->headvex]=true;
                    visit_(p->headvex);
                    addQ(Q,p->headvex);
                    //如果能找到这个结点，就走这条路，掉头
                    p=Graph->G[p->headvex].firstOut;
                }else{
                    p=p->tlink;
                }
            }
            v=deleteQ(Q);
            p=Graph->G[v].firstOut;
        }
        }
    }
}

//矩阵的深度搜索非递归
void In_DFS_matric(MGraph Graph,Vertex v,void(*visit_)(Vertex)){
    int i,count=0;
    /*用一个count计次，一直到count==nv的时候停止*/
    while(count!=Graph->nv){
        visit_(v);
        visited[v]=true;
        count++;
        for(i=0;i<Graph->nv;i++){
            if(Graph->G[v][i]<INFINITY && visited[i]==false){
                v=i;//把找到的数字记录下来
                break;
            }
        }
    }
}

//矩阵的深度递归搜索
void DFS_matric(MGraph Graph,Vertex v,void(*visit_)(Vertex)){
    int i;
    visit_(v);
    visited[v]=true;
    for(i=0;i<Graph->nv;i++){
        if(Graph->G[v][i]<INFINITY && visited[i]==false)
            DFS_matric(Graph,i,visit_);//一直递归调用
    }
}

//判断是不是边
int IsEdge(MGraph Graph,Vertex v,Vertex w){
    return Graph->G[v][w]<INFINITY?true:false;
}


void visit_(Vertex s){
    printf("%d ",s);
}

//创建空队列
queue CreatQueue(){
    queue Q=(queue)malloc((sizeof(struct QNode)));
    //Q->data=(element *)malloc(maxSize*sizeof(element));//???
    Q->front=Q->rear=0;
    //Q->maxSize=maxSize;
    return Q;
}

//列队是不是满的
int Isfull(queue Q){
    if((Q->rear+1)%maxSize==Q->front)
        return 1;
    else
        return 0;
}

//添加新队列
void addQ(queue Q,element1 x){
    /*printf("\n");
    printf("rear:%d\n",Q->rear);
    printf("front:%d\n",Q->front);*/
    if(Isfull(Q)){
        printf("列队满");
        exit(0);
    }else{
        Q->rear=(Q->rear+1)%maxSize;
        Q->data1[Q->rear]=x;
        //printf("进来一个元素\n");
    }
    /*printf("rear:%d\n",Q->rear);
    printf("front:%d\n",Q->front);
    printf("本次添加结束\n");
     printf("\n");*/
}

//判断队列是否为空
int isEmpty(queue Q){
    if(Q->front==Q->rear){
        //printf("队列空了");
        return 1;
    }
    else{
        //printf("队列不空");
        return 0;
    }

}

//删除队列中的元素,返回弹出的地址
element1 deleteQ(queue Q){
    /*printf("\n");
    printf("rear:%d\n",Q->rear);
    printf("front:%d\n",Q->front);*/
    if(isEmpty(Q)){
        printf("队列空");
        exit(0);
    }else{
    //printf("出去一个元素\n");
    Q->front=(Q->front+1)%(maxSize);//删掉前的地址
    return Q->data1[Q->front];//返回的是一个队列里的元素，即一个地址
    /*printf("\n");
    printf("rear:%d\n",Q->rear);
    printf("front:%d\n",Q->front);*/
    }

}

//建立邻接表的图
LGraph biuldGraph_adjacencyList(){
    LGraph Graph;
    Edge E;
    int nv,i;

    FILE*fp;
     if((fp=fopen("E://数据结构//图 实验//matric1.txt","r"))==NULL)
    {
        printf("fail to open!");
        exit(0);
    }
    fscanf(fp,"%d\n",&nv);//顶点个数
    Graph=CreateGraph_adjacencyList(nv);//初始化有nv个顶点但没有边的图

    fscanf(fp,"%d\n",&Graph->ne);//读入边数
    if(Graph->ne!=0){
        E=(Edge)malloc(sizeof(struct ENode));
        for(i=0;i<Graph->ne;i++){
            fscanf(fp,"%d %d %d\n",&E->v1,&E->v2,&E->weight);//读入边的信息
            InsertEdge_adjacencyList(Graph,E);//把这条边插入矩阵信息中
        }
    }
    //读入顶点的数据
    for(i=0;i<Graph->nv;i++){
        fscanf(fp,"%c",&Graph->G[i].data);//读入A、B、C顶点的数据
    }
    return Graph;
}

//初始化有nv个顶点但没有边的图
LGraph CreateGraph_adjacencyList(int nvNum){
    Vertex v;
    LGraph Graph;
    //为这个图申请空间
    Graph =(LGraph)malloc(sizeof(struct GNode));
    Graph->nv=nvNum;
    //边数设置为0，并且将各条边的间距设置成无穷大，表示不连接
    Graph->ne=0;
    for(v=0;v<Graph->nv;v++)
        Graph->G[v].firstEdge=NULL;
    return Graph;
}

//把这条边插入邻接表信息中
void InsertEdge_adjacencyList(LGraph Graph,Edge E){
    PtrToAdjvNode newnode;//定义一个表头结点
    //建立一个v2邻接点
    newnode=(PtrToAdjvNode)malloc(sizeof(struct AdjvNode));
    newnode->Adjv=E->v2;
    newnode->weight=E->weight;
    //将v2插入v1表头
    newnode->next=Graph->G[E->v1].firstEdge;
    Graph->G[E->v1].firstEdge=newnode;
}


//建立十字链表的图
OLGraph biuldGraph_arc(){
    OLGraph Graph;
    Edge E;
    int nv,i;

    FILE*fp;
     if((fp=fopen("E://数据结构//图 实验//matric1.txt","r"))==NULL)
    {
        printf("fail to open!");
        exit(0);
    }
    fscanf(fp,"%d\n",&nv);//顶点个数
    Graph=CreateGraph_arc(nv);//初始化有nv个顶点但没有边的图

    fscanf(fp,"%d\n",&Graph->ne);//读入边数
    if(Graph->ne!=0){
        E=(Edge)malloc(sizeof(struct ENode));
        //A=(Arcbox)malloc(sizeof(struct ArcNode));//为结点申请空间
        for(i=0;i<Graph->ne;i++){
            fscanf(fp,"%d %d %d\n",&E->v1,&E->v2,&E->weight);//读入边的信息
            //fscanf(fp,"%d %d %d\n",&A->tailvex,&A->headvex,&A->weight);//读入边的信息
            InsertEdge_arc(Graph,E);//把这条边插入矩阵信息中
        }
    }
    //读入顶点的数据
    for(i=0;i<Graph->nv;i++){
        fscanf(fp,"%c",&Graph->G[i].data);//读入A、B、C顶点的数据
    }
    return Graph;

}

//初始化有nv个顶点但没有边的图
OLGraph CreateGraph_arc(int nvNum){
    Vertex v;
    OLGraph Graph;
    //为这个图申请空间
    Graph =(OLGraph)malloc(sizeof(struct OLGNode));
    Graph->nv=nvNum;
    Graph->ne=0;
    /*
    for(v=0;v<Graph->nv;v++)
        Graph->G[v].firstIn=NULL;
        Graph->G[v].firstOut=NULL;出错原因！！

    */
    for(v=0;v<Graph->nv;v++){
        Graph->G[v].firstIn=NULL;
        Graph->G[v].firstOut=NULL;
    }
    return Graph;
}

//把这条边插入邻接表信息中
void InsertEdge_arc(OLGraph Graph,Edge E){
    Arcbox A;
    A=(Arcbox)malloc(sizeof(struct ArcNode));//为结点申请空间

    A->weight=E->weight;
    A->headvex=E->v2;
    A->tailvex=E->v1;

    A->tlink=Graph->G[A->tailvex].firstOut;//出去的指针解决了
    Graph->G[A->tailvex].firstOut=A;//把出去的边连接上
    //解决firstIn,hlink的指针
    A->hlink=Graph->G[A->headvex].firstIn;
    Graph->G[A->headvex].firstIn=A;
}

//邻接矩阵最小生成树
LGraph Prim_matric(MGraph Graph){
    LGraph MST;
    weightType dist[MaxVertexNum],totalWeight;
    Vertex parent[MaxVertexNum],i,j;
    int Vcount;
    Edge E;

    //初始化
    for(i=0;i<Graph->nv;i++){
        //dist里边收录的是距离的大小
        dist[i]=Graph->G[0][i];
        parent[i]=0;
    }
    Vcount=0;
    totalWeight=0;

    //用邻接表来承接树的信息
    //创建一个有顶点但是没有边的邻接表
    MST=CreateGraph_adjacencyList(Graph->nv);
    E=(Edge)malloc(sizeof(struct ENode));

    //找一个初始点
    dist[0]=0;
    Vcount++;
    parent[0]=-1;//树根

    while(1){
        i=findMinDist_matric(Graph,dist);
        if(i==ERROR)
            break;
        E->v1=parent[i];
        E->v2=i;
        E->weight=dist[i];
        InsertEdge_adjacencyList(MST,E);
        totalWeight+=dist[i];
        dist[i]=0;//标记成访问过
        Vcount++;

        for(j=0;j<Graph->nv;j++){
            if(dist[j]!=0 &&Graph->G[i][j]<INFINITY){
                //未被收录进树+距离最小，收录
                if(Graph->G[i][j]<dist[j]){
                    dist[j]=Graph->G[i][j];
                    parent[j]=i;
                }
            }
        }
    }
        if(Vcount<Graph->nv){
            totalWeight=ERROR;
            printf("不是最小生成树\n");
        }
            printf("最小树的权值和%d\n",totalWeight);
            return MST;
}

//寻找最小的权值点
Vertex findMinDist_matric(MGraph Graph,weightType dist[]){
    Vertex Minv,v;
    weightType MinDist=INFINITY;

    for(v=0;v<Graph->nv;v++){
        if(dist[v]!=0 &&dist[v]<INFINITY){
            MinDist=dist[v];
            Minv=v;
        }
    }

    if(MinDist<INFINITY)
        return Minv;
    else return ERROR;
}



//邻接表最小生成树
LGraph Prim_adjacencyList(LGraph Graph){
    LGraph MST;
    PtrToAdjvNode w,y;
    weightType dist[MaxVertexNum],totalWeight;
    Vertex parent[MaxVertexNum],i;
    int Vcount;
    Edge E;

    //初始化
    for(i=0;i<Graph->nv;i++){
        dist[i]=INFINITY;//先假设都没有边
        parent[i]=0;
    }
    w=Graph->G[0].firstEdge;
    while(w){
        dist[w->Adjv]=w->weight;
        //第一次的时候忘记写，循环的步骤！！！
        w=w->next;
    }
    Vcount=0;
    totalWeight=0;

    //用邻接表来承接树的信息
    //创建一个有顶点但是没有边的邻接表
    MST=CreateGraph_adjacencyList(Graph->nv);
    E=(Edge)malloc(sizeof(struct ENode));

    //找一个初始点
    dist[0]=0;
    Vcount++;
    parent[0]=-1;//树根
    while(1){
        //找在这个顶点下，哪条边最短
        i=findMinDist_adjacencyList(Graph,dist);
        //printf("%d\n",i);
        if(i==ERROR)
            break;
        E->v1=parent[i];
        E->v2=i;
        E->weight=dist[i];
        InsertEdge_adjacencyList(MST,E);
        totalWeight+=dist[i];
        dist[i]=0;//标记成访问过
        Vcount++;

        //找下一个顶点
        y=Graph->G[i].firstEdge;
        while(y){
            if(dist[y->Adjv]!=0){
                if(y->weight < dist[y->Adjv]){
                    dist[y->Adjv]=y->weight;
                    parent[y->Adjv]=i;
                }
            }
            y=y->next;
        }
        }
        if(Vcount<Graph->nv){
            totalWeight=ERROR;
            printf("不是最小生成树\n");
        }
            printf("最小树的权值和%d\n",totalWeight);
            return MST;
}

//寻找最小的权值点
Vertex findMinDist_adjacencyList(LGraph Graph,weightType dist[]){
    Vertex Minv,v;
    weightType MinDist=INFINITY;

    for(v=0;v<Graph->nv;v++){
        if(dist[v]!=0 &&dist[v]<INFINITY){
            MinDist=dist[v];
            Minv=v;
        }
    }

    if(MinDist<INFINITY)
        return Minv;
    else return ERROR;
}


//时间的比较 邻接矩阵的广度
void run1(MGraph Graph)
{
    int i;
    Vertex s=accessVisit();//开始访问的结点
    start=clock();
    for(i=0;i<MAXK;i++){
       InitialVisted();//初始化访问tag
       BFS_matric(Graph,s,visit_);
    }
    stop=clock();
    duration=((double)(stop-start))/CLK_TCK;
    printf("邻接矩阵ticks=%f\n",(double)(stop-start));
    printf("邻接矩阵duration=%6.2e\n",duration);
}

//邻接表的广度
void run2(LGraph Graph)
{
    int i;
    Vertex s=accessVisit();//开始访问的结点
    start=clock();
    for(i=0;i<MAXK;i++){
        InitialVisted();//初始化访问tag
        BFS_adjacencyList(Graph,s,visit_);
    }
    stop=clock();
    duration=((double)(stop-start))/CLK_TCK;
    printf("邻接表ticks=%f\n",(double)(stop-start));
    printf("邻接表duration=%6.2e\n",duration);
}

//十字链表的广度
void run3(OLGraph Graph)
{
    int i;
    Vertex s=accessVisit();//开始访问的结点
    start=clock();
    for(i=0;i<MAXK;i++){
        InitialVisted();//初始化访问tag
        BFS_arc(Graph,s,visit_);
    }
    stop=clock();
    duration=((double)(stop-start))/CLK_TCK;
    printf("十字链表ticks=%f\n",(double)(stop-start));
    printf("十字链表duration=%6.2e\n",duration);
}
