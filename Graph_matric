#include <stdio.h>
#include <stdlib.h>
#define MaxVertexNum 100 //顶点数设置为100
#define INFINITY 100000
#define maxSize 100
typedef enum{false = 0,true = 1}PointTag;
int visited[MaxVertexNum];
typedef int weightType;
typedef char dataType;
/*邻接矩阵*/
struct GNode{
    int nv;//顶点数
    int ne;//边数
    weightType G[MaxVertexNum][MaxVertexNum];//邻接矩阵某条边的权值
    dataType data[MaxVertexNum];//存顶点的数据
};
typedef struct GNode *MGraph;

/*邻接矩阵边的定义*/
typedef int Vertex;
struct ENode{
    Vertex v1,v2;
    weightType weight;
};
typedef struct ENode *Edge;

typedef Vertex element1;//!!!!好好理解！！
typedef int position;
struct QNode{
    element1 data1[maxSize];//存储元素的数组,数组里边放的全部都是指针
    position front,rear;//队列的头尾指针
};
typedef struct QNode *queue;//没有*不行？？？

Vertex accessVisit();//想要去开始进入的点
void InitialVisted();//初始化访问tag
MGraph biuldGraph_matric();
MGraph CreateGraph_matric(int nvNum);//初始化有nv个顶点但没有边的图
void InsertEdge_matric(MGraph Graph,Edge E);//在矩阵中插入边
void BFS_matric(MGraph Graph,Vertex s,void(*visit_)(MGraph,Vertex));//邻接矩阵的广度优先搜索
queue CreatQueue();//创建空队列
int Isfull(queue Q);//列队是不是满的
void addQ(queue Q,element1 x);//添加新队列
int isEmpty(queue Q);//判断队列是否为空
element1 deleteQ(queue Q);//删除队列中的元素,返回弹出的地址
void visit_(MGraph Graph,Vertex s);
int IsEdge(MGraph Graph,Vertex v,Vertex w);//判断是不是边
void InitialVisted();//初始化访问tag
int main()
{
    int i;
    MGraph Graph;
    Vertex s=accessVisit();//开始访问的结点
    InitialVisted();//初始化访问tag
    /*
    Graph=biuldGraph_matric();
    printf("邻接矩阵的广度优先搜索：\n");
    BFS_matric(Graph,s,visit_);*/
    //printf("%d\n",Graph->G[4][3]);
    //printf("%d\n",Graph->nv);测试，已经成功读入
    //printf("%c\n",Graph->data[2]);
    return 0;
}

//想要去开始进入的点
Vertex accessVisit(){
    Vertex s =0;
    return s;
}

MGraph biuldGraph_matric(){
    MGraph Graph;
    Edge E;
    int nv,i;
    //读入顶点个数
    FILE*fp;
     if((fp=fopen("E://数据结构//图 实验//matric.txt","r"))==NULL)
    {
        printf("fail to open!");
        exit(0);
    }
    fscanf(fp,"%d\n",&nv);//顶点个数
    Graph=CreateGraph_matric(nv);//初始化有nv个顶点但没有边的图

    fscanf(fp,"%d\n",&Graph->ne);//读入边数
    if(Graph->ne!=0){
        E=(Edge)malloc(sizeof(struct ENode));
        for(i=0;i<Graph->ne;i++){
            fscanf(fp,"%d %d %d\n",&E->v1,&E->v2,&E->weight);//读入边的信息
            InsertEdge_matric(Graph,E);//把这条边插入矩阵信息中
        }
    }
    //读入顶点的数据
    for(i=0;i<Graph->nv;i++){
        fscanf(fp,"%c",&Graph->data[i]);//读入A、B、C顶点的数据
    }
    return Graph;
}
//初始化有nv个顶点但没有边的图
MGraph CreateGraph_matric(int nvNum){
    Vertex v,w;
    MGraph Graph;
    //为这个图申请空间
    Graph =(MGraph)malloc(sizeof(struct GNode));
    Graph->nv=nvNum;
    //边数设置为0，并且将各条边的间距设置成无穷大，表示不连接
    Graph->ne=0;
    for(v=0;v<Graph->nv;v++){
        for(w=0;w<Graph->nv;w++){
            Graph->G[v][w]=INFINITY;
        }

    }
    return Graph;
}

//在矩阵中插入边
void InsertEdge_matric(MGraph Graph,Edge E){
    Graph->G[E->v1][E->v2]=E->weight;
}

//初始化访问tag
void InitialVisted(){
    int i;
    for(i=0;i<MaxVertexNum;i++){
        visited[i]=0;
    }
}

//邻接矩阵的广度优先搜索
void BFS_matric(MGraph Graph,Vertex s,void(*visit_)(MGraph,Vertex)){
    queue Q;
    Vertex v,w;

    Q=CreatQueue();//创建空的队列

    visit_(Graph,s);//访问s顶点,并打印
    visited[s]=true;
    addQ(Q,s);//将s加入队列

    while(!isEmpty(Q)){
        v=deleteQ(Q);//把v弹出
        for(w=0;w<Graph->nv;w++){
                //判断是不是边
            if(!visited[w]&&IsEdge(Graph,v,w)){
                visit_(Graph,w);
                visited[w]=true;
                addQ(Q,w);//w入队
            }



        }
    }
}

//判断是不是边
int IsEdge(MGraph Graph,Vertex v,Vertex w){
    return Graph->G[v][w]<INFINITY?true:false;
}


void visit_(MGraph Graph,Vertex s){
    printf("%c ",Graph->data[s]);
}

//创建空队列
queue CreatQueue(){
    queue Q=(queue)malloc((sizeof(struct QNode)));
    //Q->data=(element *)malloc(maxSize*sizeof(element));//???
    Q->front=Q->rear=0;
    //Q->maxSize=maxSize;
    return Q;
}

//列队是不是满的
int Isfull(queue Q){
    if((Q->rear+1)%maxSize==Q->front)
        return 1;
    else
        return 0;
}

//添加新队列
void addQ(queue Q,element1 x){
    /*printf("\n");
    printf("rear:%d\n",Q->rear);
    printf("front:%d\n",Q->front);*/
    if(Isfull(Q)){
        printf("列队满");
        exit(0);
    }else{
        Q->rear=(Q->rear+1)%maxSize;
        Q->data1[Q->rear]=x;
        //printf("进来一个元素\n");
    }
    /*printf("rear:%d\n",Q->rear);
    printf("front:%d\n",Q->front);
    printf("本次添加结束\n");
     printf("\n");*/
}

//判断队列是否为空
int isEmpty(queue Q){
    if(Q->front==Q->rear){
        //printf("队列空了");
        return 1;
    }
    else{
        //printf("队列不空");
        return 0;
    }

}

//删除队列中的元素,返回弹出的地址
element1 deleteQ(queue Q){
    /*printf("\n");
    printf("rear:%d\n",Q->rear);
    printf("front:%d\n",Q->front);*/
    if(isEmpty(Q)){
        printf("队列空");
        exit(0);
    }else{
    //printf("出去一个元素\n");
    Q->front=(Q->front+1)%(maxSize);//删掉前的地址
    return Q->data1[Q->front];//返回的是一个队列里的元素，即一个地址
    /*printf("\n");
    printf("rear:%d\n",Q->rear);
    printf("front:%d\n",Q->front);*/
    }

}
